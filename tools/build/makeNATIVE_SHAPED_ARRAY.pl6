# This script reads the native_array.pm file from STDIN, and generates the
# shapedintarray, shapednumarray and shapedstrarray roles in it, and writes
# it to STDOUT.

use v6;

my $generator = $*PROGRAM-NAME;
my $generated = DateTime.now.gist.subst(/\.\d+/,'');
my $start     = '#- start of generated part of shaped';
my $idpos     = $start.chars;
my $idchars   = 3;
my $end       = '#- end of generated part of shaped';

# for all the lines in the source that don't need special handling
for $*IN.lines -> $line {

    # nothing to do yet
    unless $line.starts-with($start) {
        say $line;
        next;
    }

    # found header
    my $type = $line.substr($idpos,$idchars);
    die "Don't know how to handle $type" unless $type eq "int" | "num" | "str";
    say $start ~ $type ~ "array role -----------------------------";
    say "#- Generated on $generated by $generator";
    say "#- PLEASE DON'T CHANGE ANYTHING BELOW THIS LINE";

    # skip the old version of the code
    for $*IN.lines -> $line {
        last if $line.starts-with($end);
    }

    # set up template values
    my %mapper =
      postfix => $type.substr(0,1),
      type    => $type,
      Type    => $type.tclc,
    ;

    # spurt the role
    say Q:to/SOURCE/.subst(/ '#' (\w+) '#' /, -> $/ { %mapper{$0} }, :g).chomp;

        proto method AT-POS(|) is raw {*}
        multi method AT-POS(shaped#type#array:U: |c) is raw {
            self.Any::AT-POS(|c)
        }
        multi method AT-POS(shaped#type#array:D: **@indices) is raw {
            my int $numdims = nqp::numdimensions(self);
            my int $numind  = @indices.elems;
            if $numind == $numdims {
                my $idxs := nqp::list_i;
                while $numdims > 0 {
                    nqp::push_i($idxs, @indices.shift);
                    $numdims = $numdims - 1;
                }
#?if moar
                nqp::multidimref_#postfix#(self, $idxs)
#?endif
#?if !moar
                nqp::atposnd_#postfix#(self, $idxs)
#?endif
            }
            elsif $numind > $numdims {
                X::TooManyDimensions.new(
                    operation => 'access',
                    got-dimensions => $numind,
                    needed-dimensions => $numdims
                ).throw
            }
            else {
                X::NYI.new(feature => "Partially dimensioned views of arrays").throw
            }
        }

        proto method ASSIGN-POS(|) {*}
        multi method ASSIGN-POS(shaped#type#array:U: |c) {
            self.Any::ASSIGN-POS(|c)
        }
        multi method ASSIGN-POS(shaped#type#array:D: **@indices) {
            my #type# $value   = @indices.pop;
            my int $numdims = nqp::numdimensions(self);
            my int $numind  = @indices.elems;
            if $numind == $numdims {
                my $idxs := nqp::list_i;
                while $numdims > 0 {
                    nqp::push_i($idxs, @indices.shift);
                    $numdims = $numdims - 1;
                }
                nqp::bindposnd_#postfix#(self, $idxs, $value)
            }
            elsif $numind > $numdims {
                X::TooManyDimensions.new(
                    operation => 'assign to',
                    got-dimensions => $numind,
                    needed-dimensions => $numdims
                ).throw
            }
            else {
                X::NotEnoughDimensions.new(
                    operation => 'assign to',
                    got-dimensions => $numind,
                    needed-dimensions => $numdims
                ).throw
            }
        }
SOURCE

    # we're done for this role
    say "#- PLEASE DON'T CHANGE ANYTHING ABOVE THIS LINE";
    say $end ~ $type ~ "array role -------------------------------";
}
