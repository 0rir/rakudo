use v6.e.PREVIEW;
use Test;

plan 12;

my $ast;
my $deparsed;
my $raku;
sub ast(RakuAST::Node:D $node --> Nil) {
    $ast      := $node;
    $deparsed := $node.DEPARSE;
    $raku     := 'use experimental :rakuast; ' ~ $node.raku;
    diag $deparsed.chomp;
}

subtest 'Simple leading and trailing pod declarator test' => {
    # #| leading comment␤sub a { 42 }␤#= trailing comment
    ast RakuAST::Doc::Declarator.new(   # created from declarator's viewpoint
      WHEREFORE => RakuAST::Sub.new(
        name => RakuAST::Name.from-identifier("a"),
        body => RakuAST::Blockoid.new(
          RakuAST::StatementList.new(
            RakuAST::Statement::Expression.new(
              expression => RakuAST::IntLiteral.new(42)
            )
          )
        )
      ),
      leading => (
        RakuAST::StrLiteral.new("leading comment"),
      ),
      trailing => (
        RakuAST::StrLiteral.new("trailing comment"),
      )
    );

    for 'Str', $deparsed, 'Raku', $raku.EVAL.DEPARSE -> $type, $it {
        is $it, q:to/CODE/.chomp, "$type: deparse";
#| leading comment
sub a { 42 }
#= trailing comment
CODE
    }
}

subtest 'Simple sub with leading and trailing pod test' => {
    # #| leading comment␤sub a { 42 }␤#= trailing comment
    ast RakuAST::Sub.new(   # created from sub's viewpoint
      name => RakuAST::Name.from-identifier("a"),
      body => RakuAST::Blockoid.new(
        RakuAST::StatementList.new(
          RakuAST::Statement::Expression.new(
            expression => RakuAST::IntLiteral.new(42)
          )
        )
      ),
      WHY  => RakuAST::Doc::Declarator.new(
        leading => (
          RakuAST::StrLiteral.new("leading comment"),
        ),
        trailing => (
          RakuAST::StrLiteral.new("trailing comment"),
        )
      )
    );

    for 'Str', $deparsed, 'Raku', $raku.EVAL.DEPARSE -> $type, $it {
        is $it, q:to/CODE/.chomp, "$type: deparse";
#| leading comment
sub a { 42 }
#= trailing comment
CODE
    }
}

subtest 'Simple class with declarator pod' => {
    # #| leading comment␤class A { }␤#= trailing comment
    ast RakuAST::Package.new(
      declarator => "class",
      name       => RakuAST::Name.from-identifier("A"),
      body       => RakuAST::Block.new(
        body => RakuAST::Blockoid.new(
          RakuAST::StatementList.new()
        )
      ),
      WHY => RakuAST::Doc::Declarator.new(
        leading   => (
          RakuAST::StrLiteral.new("leading comment"),
        ),
        trailing   => (
          RakuAST::StrLiteral.new("trailing comment"),
        )
      )
    );

    for 'Str', $deparsed, 'Raku', $raku.EVAL.DEPARSE -> $type, $it {
        is $it, q:to/CODE/.chomp, "$type: deparse";
#| leading comment
class A { }
#= trailing comment
CODE
    }
}

subtest 'Simple class with declarator pod, one attribute' => {
    # class A {␤    #| leading comment␤    has $.foo␤    #= trailing comment␤}␤
    ast RakuAST::Package.new(
      declarator => "class",
      name       => RakuAST::Name.from-identifier("A"),
      body       => RakuAST::Block.new(
        body => RakuAST::Blockoid.new(
          RakuAST::StatementList.new(
            RakuAST::Statement::Expression.new(
              expression => RakuAST::VarDeclaration::Simple.new(
                scope => "has",
                name  => '$.foo',
                WHY => RakuAST::Doc::Declarator.new(
                  leading   => (
                    RakuAST::StrLiteral.new("leading comment"),
                  ),
                  trailing   => (
                    RakuAST::StrLiteral.new("trailing comment"),
                  )
                )
              )
            )
          )
        )
      ),
    );

    for 'Str', $deparsed, 'Raku', $raku.EVAL.DEPARSE -> $type, $it {
        is $it, q:to/CODE/, "$type: deparse";
class A {
    #| leading comment
    has $.foo
    #= trailing comment
}
CODE
    }
}

subtest 'Simple class with declarator pod, two attributes' => {
    # class A {␤    #| leading comment␤    has $.foo␤    #= trailing comment␤    has $.bar␤}␤
    ast RakuAST::Package.new(
      declarator => "class",
      name       => RakuAST::Name.from-identifier("A"),
      body       => RakuAST::Block.new(
        body => RakuAST::Blockoid.new(
          RakuAST::StatementList.new(
            RakuAST::Statement::Expression.new(
              expression => RakuAST::VarDeclaration::Simple.new(
                scope => "has",
                name  => '$.foo',
                WHY => RakuAST::Doc::Declarator.new(
                  leading   => (
                    RakuAST::StrLiteral.new("leading comment"),
                  ),
                  trailing   => (
                    RakuAST::StrLiteral.new("trailing comment"),
                  )
                )
              )
            ),
            RakuAST::Statement::Expression.new(
              expression => RakuAST::VarDeclaration::Simple.new(
                scope => "has",
                name  => '$.bar'
              )
            )
          )
        )
      ),
    );

    for 'Str', $deparsed, 'Raku', $raku.EVAL.DEPARSE -> $type, $it {
        is $it, q:to/CODE/, "$type: deparse";
class A {
    #| leading comment
    has $.foo
    #= trailing comment
    has $.bar
}
CODE
    }
}

subtest 'Simple class with declarator pod, one method' => {
    # class A {␤    #| leading comment␤    method foo() { }␤    #= trailing comment␤}␤
    ast RakuAST::Package.new(
      declarator => "class",
      name       => RakuAST::Name.from-identifier("A"),
      body       => RakuAST::Block.new(
        body => RakuAST::Blockoid.new(
          RakuAST::StatementList.new(
            RakuAST::Statement::Expression.new(
              expression => RakuAST::Method.new(
                name => RakuAST::Name.from-identifier("foo"),
                body => RakuAST::Blockoid.new(
                  RakuAST::StatementList.new()
                ),
                WHY  => RakuAST::Doc::Declarator.new(
                  leading  => (
                    RakuAST::StrLiteral.new("leading comment"),
                  ),
                  trailing => (
                    RakuAST::StrLiteral.new("trailing comment"),
                  )
                )
              )
            )
          )
        )
      )
    );

    for 'Str', $deparsed, 'Raku', $raku.EVAL.DEPARSE -> $type, $it {
        is $it, q:to/CODE/, "$type: deparse";
class A {
    #| leading comment
    method foo { }
    #= trailing comment
}
CODE
    }
}

subtest 'Simple class with declarator pod, one submethod' => {
    # class A {␤    #| leading comment␤    submethod foo() { }␤    #= trailing comment␤}␤
    ast RakuAST::Package.new(
      declarator => "class",
      name       => RakuAST::Name.from-identifier("A"),
      body       => RakuAST::Block.new(
        body => RakuAST::Blockoid.new(
          RakuAST::StatementList.new(
            RakuAST::Statement::Expression.new(
              expression => RakuAST::Submethod.new(
                name => RakuAST::Name.from-identifier("foo"),
                body => RakuAST::Blockoid.new(
                  RakuAST::StatementList.new()
                ),
                WHY  => RakuAST::Doc::Declarator.new(
                  leading  => (
                    RakuAST::StrLiteral.new("leading comment"),
                  ),
                  trailing => (
                    RakuAST::StrLiteral.new("trailing comment"),
                  )
                )
              )
            )
          )
        )
      )
    );

    for 'Str', $deparsed, 'Raku', $raku.EVAL.DEPARSE -> $type, $it {
        is $it, q:to/CODE/, "$type: deparse";
class A {
    #| leading comment
    submethod foo { }
    #= trailing comment
}
CODE
    }
}

subtest 'Simple class with declarator pod, one private method' => {
    # class A {␤    #| leading comment␤    method !foo() { }␤    #= trailing comment␤}␤
    ast RakuAST::Package.new(
      declarator => "class",
      name       => RakuAST::Name.from-identifier("A"),
      body       => RakuAST::Block.new(
        body => RakuAST::Blockoid.new(
          RakuAST::StatementList.new(
            RakuAST::Statement::Expression.new(
              expression => RakuAST::Method.new(
                name    => RakuAST::Name.from-identifier("foo"),
                body    => RakuAST::Blockoid.new(
                  RakuAST::StatementList.new()
                ),
                private => True,
                WHY     => RakuAST::Doc::Declarator.new(
                  leading  => (
                    RakuAST::StrLiteral.new("leading comment"),
                  ),
                  trailing => (
                    RakuAST::StrLiteral.new("trailing comment"),
                  )
                )
              )
            )
          )
        )
      )
    );

    for 'Str', $deparsed, 'Raku', $raku.EVAL.DEPARSE -> $type, $it {
        is $it, q:to/CODE/, "$type: deparse";
class A {
    #| leading comment
    method !foo { }
    #= trailing comment
}
CODE
    }
}

subtest 'Simple class with declarator pod, one meta method' => {
    # class A {␤    #| leading comment␤    method ^foo() { }␤    #= trailing comment␤}␤
    ast RakuAST::Package.new(
      declarator => "class",
      name       => RakuAST::Name.from-identifier("A"),
      body       => RakuAST::Block.new(
        body => RakuAST::Blockoid.new(
          RakuAST::StatementList.new(
            RakuAST::Statement::Expression.new(
              expression => RakuAST::Method.new(
                name => RakuAST::Name.from-identifier("foo"),
                body => RakuAST::Blockoid.new(
                  RakuAST::StatementList.new()
                ),
                meta => True,
                WHY  => RakuAST::Doc::Declarator.new(
                  leading  => (
                    RakuAST::StrLiteral.new("leading comment"),
                  ),
                  trailing => (
                    RakuAST::StrLiteral.new("trailing comment"),
                  )
                )
              )
            )
          )
        )
      )
    );

    for 'Str', $deparsed, 'Raku', $raku.EVAL.DEPARSE -> $type, $it {
        is $it, q:to/CODE/, "$type: deparse";
class A {
    #| leading comment
    method ^foo { }
    #= trailing comment
}
CODE
    }
}

subtest 'Simple class with declarator pod, two methods' => {
    # class A {␤    #| leading comment␤    method foo() { }␤    #= trailing comment␤    method bar { }␤}␤
    ast RakuAST::Package.new(
      declarator => "class",
      name       => RakuAST::Name.from-identifier("A"),
      body       => RakuAST::Block.new(
        body => RakuAST::Blockoid.new(
          RakuAST::StatementList.new(
            RakuAST::Statement::Expression.new(
              expression => RakuAST::Method.new(
                name => RakuAST::Name.from-identifier("foo"),
                body => RakuAST::Blockoid.new(
                  RakuAST::StatementList.new()
                ),
                WHY  => RakuAST::Doc::Declarator.new(
                  leading  => (
                    RakuAST::StrLiteral.new("leading comment"),
                  ),
                  trailing => (
                    RakuAST::StrLiteral.new("trailing comment"),
                  )
                )
              )
            ),
            RakuAST::Statement::Expression.new(
              expression => RakuAST::Method.new(
                name => RakuAST::Name.from-identifier("bar"),
                body => RakuAST::Blockoid.new(
                  RakuAST::StatementList.new()
                )
              )
            )
          )
        )
      )
    );

    for 'Str', $deparsed, 'Raku', $raku.EVAL.DEPARSE -> $type, $it {
        is $it, q:to/CODE/, "$type: deparse";
class A {
    #| leading comment
    method foo { }
    #= trailing comment
    method bar { }
}
CODE
    }
}

subtest 'Simple enum with declarator pod' => {
    # #| leading comment␤enum Foo <A B C>␤#= trailing comment
    ast RakuAST::Type::Enum.new(
      name => RakuAST::Name.from-identifier("Foo"),
      term => RakuAST::QuotedString.new(
        processors => <words val>,
        segments   => (
          RakuAST::StrLiteral.new("A B C"),
        )
      ),
      WHY => RakuAST::Doc::Declarator.new(
        leading   => (
          RakuAST::StrLiteral.new("leading comment"),
        ),
        trailing   => (
          RakuAST::StrLiteral.new("trailing comment"),
        )
      )
    );

    for 'Str', $deparsed, 'Raku', $raku.EVAL.DEPARSE -> $type, $it {
        is $it, q:to/CODE/.chomp, "$type: deparse";
#| leading comment
enum Foo <A B C>
#= trailing comment
CODE
    }
}

subtest 'Simple subset with declarator pod' => {
    # #| leading comment␤subset Foo of Int␤#= trailing comment
    ast RakuAST::Type::Subset.new(
      name => RakuAST::Name.from-identifier("Foo"),
      of   => RakuAST::Trait::Of.new(
        RakuAST::Type::Simple.new(
          RakuAST::Name.from-identifier("Int")
        )
      ),
      WHY => RakuAST::Doc::Declarator.new(
        leading   => (
          RakuAST::StrLiteral.new("leading comment"),
        ),
        trailing   => (
          RakuAST::StrLiteral.new("trailing comment"),
        )
      )
    );

    for 'Str', $deparsed, 'Raku', $raku.EVAL.DEPARSE -> $type, $it {
        is $it, q:to/CODE/.chomp, "$type: deparse";
#| leading comment
subset Foo of Int
#= trailing comment
CODE
    }
}

# vim: expandtab shiftwidth=4
