use MONKEY-SEE-NO-EVAL;
use experimental :rakuast;
use Test;

plan 10;

my $ast;
my $deparsed;
my @type = <AST Str AST Str>;
sub ast(RakuAST::Node:D $node --> Nil) {
    $ast      := $node;
    $deparsed := $node.DEPARSE;
    diag $deparsed.chomp;
}

class TestTarget {
    my $.route = 66;
    method subtract($x, $y) { $x - $y }
}
subtest 'Can make a call on a method without arguments' => {
    # TestTarget.route()
    ast RakuAST::ApplyPostfix.new(
      operand => RakuAST::Type::Simple.new(
        RakuAST::Name.from-identifier('TestTarget')
      ),
      postfix => RakuAST::Call::Method.new(
        name => RakuAST::Name.from-identifier('route')
      )
    );
    is-deeply $deparsed, 'TestTarget.route()', 'deparsed';
    is-deeply $_, 66, @type[$++]
      for EVAL($ast), EVAL($deparsed);
}

subtest 'Can make a call on a method with positional arguments' => {
    # TestTarget.subtract(14, 6)
    ast RakuAST::ApplyPostfix.new(
      operand => RakuAST::Type::Simple.new(
        RakuAST::Name.from-identifier('TestTarget')
      ),
      postfix => RakuAST::Call::Method.new(
        name => RakuAST::Name.from-identifier('subtract'),
        args => RakuAST::ArgList.new(
          RakuAST::IntLiteral.new(14),
          RakuAST::IntLiteral.new(6),
        )
      )
    );
    is-deeply $deparsed, 'TestTarget.subtract(14, 6)', 'deparsed';
    is-deeply $_, 8, @type[$++]
      for EVAL($ast), EVAL($deparsed);
}

subtest 'Method call WHAT compiles into MOP primitive' => {
    # 42.WHAT
    ast RakuAST::ApplyPostfix.new(
      operand => RakuAST::IntLiteral.new(42),
      postfix => RakuAST::Call::Method.new(
        name => RakuAST::Name.from-identifier('WHAT')
      )
    );
    is-deeply $deparsed, '42.WHAT', 'deparsed';
    is-deeply $_, Int, @type[$++]
      for EVAL($ast), EVAL($deparsed);
}

subtest 'Method call HOW compiles into MOP primitive' => {
    # 42.HOW
    ast RakuAST::ApplyPostfix.new(
      operand => RakuAST::IntLiteral.new(42),
      postfix => RakuAST::Call::Method.new(
        name => RakuAST::Name.from-identifier('HOW')
      )
    );
    is-deeply $deparsed, '42.HOW', 'deparsed';
    is-deeply $_, Int.HOW, @type[$++]
      for EVAL($ast), EVAL($deparsed);
}

subtest 'Method call WHO compiles into MOP primitive' => {
    # 42.WHO
    ast RakuAST::ApplyPostfix.new(
      operand => RakuAST::IntLiteral.new(42),
      postfix => RakuAST::Call::Method.new(
        name => RakuAST::Name.from-identifier('WHO')
      )
    );
    is-deeply $deparsed, '42.WHO', 'deparsed';
    isa-ok $_, Stash, @type[$++]
      for EVAL($ast), EVAL($deparsed);
}

subtest 'Method call DEFINITE compiles into MOP primitive' => {
    # 42.DEFINITE
    ast RakuAST::ApplyPostfix.new(
      operand => RakuAST::IntLiteral.new(42),
      postfix => RakuAST::Call::Method.new(
        name => RakuAST::Name.from-identifier('DEFINITE')
      )
    );
    is-deeply $deparsed, '42.DEFINITE', 'deparsed';
    is-deeply $_, True, @type[$++]
      for EVAL($ast), EVAL($deparsed);
}

subtest 'Method call REPR compiles into MOP primitive' => {
    # 42.REPR
    ast RakuAST::ApplyPostfix.new(
      operand => RakuAST::IntLiteral.new(42),
      postfix => RakuAST::Call::Method.new(
        name => RakuAST::Name.from-identifier('REPR')
      )
    );
    is-deeply $deparsed, '42.REPR', 'deparsed';
    is-deeply $_, 'P6opaque', @type[$++]
      for EVAL($ast), EVAL($deparsed);
}

subtest 'Can make a quoted call on a method without arguments' => {
    # TestTarget."route"()
    ast RakuAST::ApplyPostfix.new(
      operand => RakuAST::Type::Simple.new(
        RakuAST::Name.from-identifier('TestTarget')
      ),
      postfix => RakuAST::Call::QuotedMethod.new(
        name => RakuAST::QuotedString.new(
          :segments[RakuAST::StrLiteral.new('route')]
        )
      )
    );
    is-deeply $deparsed, 'TestTarget."route"()', 'deparsed';
    is-deeply $_, 66, @type[$++]
      for EVAL($ast), EVAL($deparsed);
}

subtest 'Can make a quoted call on a method with positional arguments' => {
    # TestTarget."subtract"(14, 6)
    ast RakuAST::ApplyPostfix.new(
      operand => RakuAST::Type::Simple.new(
        RakuAST::Name.from-identifier('TestTarget')
      ),
      postfix => RakuAST::Call::QuotedMethod.new(
        name => RakuAST::QuotedString.new(
          :segments[RakuAST::StrLiteral.new('subtract')]
        ),
        args => RakuAST::ArgList.new(
          RakuAST::IntLiteral.new(14),
          RakuAST::IntLiteral.new(6),
        )
      )
    );
    is-deeply $deparsed, 'TestTarget."subtract"(14, 6)', 'deparsed';
    is-deeply $_, 8, @type[$++]
      for EVAL($ast), EVAL($deparsed);
}

subtest 'Can make a meta-method call' => {
    # 42.^name()
    ast RakuAST::ApplyPostfix.new(
      operand => RakuAST::IntLiteral.new(42),
      postfix => RakuAST::Call::MetaMethod.new(name => 'name')
    );
    is-deeply $deparsed, '42.^name()', 'deparsed';
    is-deeply $_, 'Int', @type[$++]
      for EVAL($ast), EVAL($deparsed);
}

# vim: expandtab shiftwidth=4
