use MONKEY-SEE-NO-EVAL;
use experimental :rakuast;
use Test;

plan 8;

my $ast;
my $deparsed;
sub ast(RakuAST::Node:D $body --> Nil) {
    $ast      := RakuAST::QuotedRegex.new(:$body);
    $deparsed := $ast.DEPARSE;
    diag $deparsed.chomp;
}

sub match-ok($haystack, $expected) is test-assertion {
  subtest "matches" => {
    plan 2;
    is $haystack ~~ EVAL($ast), $expected, 'EVAL over RakuAST';
    is $haystack ~~ EVAL($deparsed), $expected, 'EVAL over deparsed AST';
  }
}

sub match-nok($haystack) is test-assertion {
  subtest "doesn't match" => {
    plan 2;
    nok $haystack ~~ EVAL($ast), 'EVAL over RakuAST';
    nok $haystack ~~ EVAL($deparsed), 'EVAL over deparsed AST';
  }
}

subtest 'Named assertion matches correctly' => {
    ast RakuAST::Regex::Assertion::Named.new(
      name      => RakuAST::Name.from-identifier('alpha'),
      capturing => True
    );
    is-deeply $deparsed, '/ <alpha> /', 'deparse';

    for 'AST', EVAL($ast), 'Str', EVAL($deparsed) -> $type, $regex {
        is "1a2" ~~ $regex, 'a',
          "$type: did we get correct match";
        is-deeply $/.hash.keys, ('alpha',).Seq,
          "$type: correct match keys";
        is $<alpha>, 'a',
          "$type: correct match captured";
    }
}

subtest 'Non-capturing named assertion matches correctly' => {
    ast RakuAST::Regex::Assertion::Named.new(
      name      => RakuAST::Name.from-identifier('alpha'),
      capturing => False
    );
    is-deeply $deparsed, '/ <.alpha> /', 'deparse';

    for 'AST', EVAL($ast), 'Str', EVAL($deparsed) -> $type, $regex {
        is "1a2" ~~ $regex, 'a',
          "$type: did we get correct match";
        is-deeply $/.hash.keys, ().Seq,
          "$type: no match keys";
    }
}

subtest 'Named assertion with alias matches correctly' => {
    # / <foo=alpha> /
    ast RakuAST::Regex::Assertion::Alias.new(
      name => 'foo',
      assertion => RakuAST::Regex::Assertion::Named.new(
        name      => RakuAST::Name.from-identifier('alpha'),
        capturing => True
      )
     );
    is-deeply $deparsed, '/ <foo=alpha> /', 'deparse';

    for 'AST', EVAL($ast), 'Str', EVAL($deparsed) -> $type, $regex {
        is "1a2" ~~ $regex, 'a',
          "$type: did we get correct match";
        is-deeply $/.hash.keys.sort, ('alpha','foo').Seq,
          "$type: correct match keys";
        is $<alpha>, 'a',
          "$type: correct match captured (original name)";
        is $<foo>, 'a',
          "$type: correct match captured (aliased name)";
    }
}

subtest 'Non-capturing named assertion with alias matches correctly' => {
    # / <foo=.alpha> /
    ast RakuAST::Regex::Assertion::Alias.new(
      name => 'foo',
      assertion => RakuAST::Regex::Assertion::Named.new(
        name      => RakuAST::Name.from-identifier('alpha'),
        capturing => False
      )
     );
    is-deeply $deparsed, '/ <foo=.alpha> /', 'deparse';

    for 'AST', EVAL($ast), 'Str', EVAL($deparsed) -> $type, $regex {
        is "1a2" ~~ $regex, 'a',
          "$type: did we get correct match";
        is-deeply $/.hash.keys, ('foo',).Seq,
          "$type: correct match keys";
        is $<foo>, 'a',
          "$type: correct match captured (aliased name)";
    }
}

subtest 'Lookahead assertion with named rule works' => {
    # / <?alpha> \w /
    ast RakuAST::Regex::Sequence.new(
      RakuAST::Regex::Assertion::Lookahead.new(
        assertion => RakuAST::Regex::Assertion::Named.new(
          name => RakuAST::Name.from-identifier('alpha'),
          capturing => True
        )
      ),
      RakuAST::Regex::CharClass::Word.new
    );
    is-deeply $deparsed, '/ <?alpha> \w /', 'deparse';

    for 'AST', EVAL($ast), 'Str', EVAL($deparsed) -> $type, $regex {
        is "!2a" ~~ $regex, 'a',
          "$type: did we get correct match";
        is $/.list.elems, 0,
          "$type: No positional captures";
        is $/.hash.elems, 0,
          "$type: No named captures";
    }
}

subtest 'Negated lookahead assertion with named rule works' => {
    # / <!alpha> \w /
    ast RakuAST::Regex::Sequence.new(
      RakuAST::Regex::Assertion::Lookahead.new(
        negated   => True,
        assertion => RakuAST::Regex::Assertion::Named.new(
          name => RakuAST::Name.from-identifier('alpha'),
          capturing => True
        )
      ),
      RakuAST::Regex::CharClass::Word.new
    );
    is-deeply $deparsed, '/ <!alpha> \w /', 'deparse';

    for 'AST', EVAL($ast), 'Str', EVAL($deparsed) -> $type, $regex {
        is "!2a" ~~ $regex, '2',
          "$type: did we get correct match";
        is $/.list.elems, 0,
          "$type: No positional captures";
        is $/.hash.elems, 0,
          "$type: No named captures";
    }
}

subtest 'Lookahead assertion calling before with a regex arg works' => {
    # / <?before \d> \w /
    ast RakuAST::Regex::Sequence.new(
      RakuAST::Regex::Assertion::Lookahead.new(
        assertion => RakuAST::Regex::Assertion::Named::RegexArg.new(
          name => RakuAST::Name.from-identifier('before'),
          regex-arg => RakuAST::Regex::CharClass::Digit.new,
        )
      ),
      RakuAST::Regex::CharClass::Word.new
    );
    is-deeply $deparsed, '/ <?before \d> \w /', 'deparse';

    for 'AST', EVAL($ast), 'Str', EVAL($deparsed) -> $type, $regex {
        is "!2a" ~~ $regex, '2',
          "$type: did we get correct match";
        is $/.list.elems, 0,
          "$type: No positional captures";
        is $/.hash.elems, 0,
          "$type: No named captures";
    }
}

subtest 'Negated lookahead assertion calling before with a regex arg works' => {
    # / <!before \d> \w /
    ast RakuAST::Regex::Sequence.new(
      RakuAST::Regex::Assertion::Lookahead.new(
        negated   => True,
        assertion => RakuAST::Regex::Assertion::Named::RegexArg.new(
          name => RakuAST::Name.from-identifier('before'),
          regex-arg => RakuAST::Regex::CharClass::Digit.new,
        )
      ),
      RakuAST::Regex::CharClass::Word.new
    );
    is-deeply $deparsed, '/ <!before \d> \w /', 'deparse';

    for 'AST', EVAL($ast), 'Str', EVAL($deparsed) -> $type, $regex {
        is "!2a" ~~ $regex, 'a',
          "$type: did we get correct match";
        is $/.list.elems, 0,
          "$type: No positional captures";
        is $/.hash.elems, 0,
          "$type: No named captures";
    }
}

# vim: expandtab shiftwidth=4
