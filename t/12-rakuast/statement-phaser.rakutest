use MONKEY-SEE-NO-EVAL;
use experimental :rakuast;
use Test;

plan 17; # Do not change this file to done-testing

my $ast;
my $deparsed;
my @type = <AST Str>;
sub ast(RakuAST::Node:D $node --> Nil) {
    $ast      := $node;
    $deparsed := $node.DEPARSE;
    diag $deparsed.chomp;
}

subtest 'BEGIN phaser producing a literal expression works' => {
    CATCH {
        when X::AdHoc {
            # Any other kind of exception or having different message means
            # different issue and we take measure not to mask it.
            .rethrow unless  .message eq q<Unknown compilation input 'qast'>;
            skip "BEGIN phaser is having some issues yet", 2;
        }
    }
    # BEGIN 12
    ast RakuAST::StatementPrefix::Phaser::Begin.new(
      RakuAST::Statement::Expression.new(
        expression => RakuAST::IntLiteral.new(12)
      )
    );

    is-deeply $deparsed, 'BEGIN 12', 'deparse';
    is-deeply $_, 12, @type[$++]
      for EVAL($ast), EVAL($deparsed);
}

subtest 'Block with CATCH/default handles exception and evalutes to Nil' => {
    my $handled;

    # { CATCH { default { $handled++ } }; die "oops" }
    ast RakuAST::Block.new(
      body => RakuAST::Blockoid.new(
        RakuAST::StatementList.new(
          RakuAST::Statement::Catch.new(
            body => RakuAST::Block.new(
              body => RakuAST::Blockoid.new(
                RakuAST::StatementList.new(
                  RakuAST::Statement::Default.new(
                    body => RakuAST::Block.new(
                      body => RakuAST::Blockoid.new(
                        RakuAST::StatementList.new(
                          RakuAST::Statement::Expression.new(
                            expression => RakuAST::ApplyPostfix.new(
                              operand => RakuAST::Var::Lexical.new('$handled'),
                              postfix => RakuAST::Postfix.new('++')
                            )
                          )
                        )
                      )
                    )
                  )
                )
              )
            )
          ),
          RakuAST::Statement::Expression.new(
            expression => RakuAST::Call::Name.new(
              name => RakuAST::Name.from-identifier('die'),
              args => RakuAST::ArgList.new(RakuAST::StrLiteral.new('oops'))
            )
          )
        )
      )
    );
    is-deeply $deparsed, Q:to/CODE/, 'deparse';
{
    CATCH {
        default {
            $handled++
        }
    }
    die("oops")
}
CODE

    for 'AST', $ast, 'Str', $deparsed -> $type, $it {
        $handled = 0;

        is-deeply EVAL($it), Nil,
          "$type: block with CATCH/default handles exception, evalutes to Nil";
        is-deeply $handled, 1, "$type: the exception handler ran once";
        is $!, 'oops', "$type: \$! in the outer scope has the exception";
    }
}

subtest 'Exception is rethrown if unhandled' => {
    # { CATCH { }; die "gosh" }
    ast RakuAST::Block.new(
      body => RakuAST::Blockoid.new(
        RakuAST::StatementList.new(
          RakuAST::Statement::Catch.new(
            body => RakuAST::Block.new(
              body => RakuAST::Blockoid.new(
                RakuAST::StatementList.new
              )
            )
          ),
          RakuAST::Statement::Expression.new(
            expression => RakuAST::Call::Name.new(
              name => RakuAST::Name.from-identifier('die'),
              args => RakuAST::ArgList.new(RakuAST::StrLiteral.new('gosh'))
            )
          )
        )
      )
    );
    is-deeply $deparsed, Q:to/CODE/, 'deparse';
{
    CATCH {
    }
    die("gosh")
}
CODE

    for 'AST', $ast, 'Str', $deparsed -> $type, $it {
        throws-like { EVAL($it) },
          X::AdHoc,
          message => /gosh/,
          "$type: exception is rethrown if unhandled";
    }
}

subtest 'CONTROL phaser catching a warning' => {
    # CONTROL {
    #     isa-ok $_, CX::Warn
    #     .resume
    # }
    # warn();
    # 42
    ast RakuAST::StatementList.new(
      RakuAST::Statement::Control.new(
        body => RakuAST::Block.new(
          body => RakuAST::Blockoid.new(
            RakuAST::StatementList.new(
              RakuAST::Statement::Expression.new(
                expression => RakuAST::Call::Name.new(
                  name => RakuAST::Name.from-identifier("isa-ok"),
                  args => RakuAST::ArgList.new(
                    RakuAST::Var::Lexical.new('$_'),
                    RakuAST::Type::Simple.new(
                      RakuAST::Name.from-identifier-parts('CX', 'Warn')
                    )
                  )
                )
              ),
              RakuAST::Statement::Expression.new(
                expression => RakuAST::Term::TopicCall.new(
                  RakuAST::Call::Method.new(
                    name => RakuAST::Name.from-identifier("resume")
                  )
                )
              )
            )
          )
        )
      ),
      RakuAST::Statement::Expression.new(
        expression => RakuAST::Call::Name.new(
          name => RakuAST::Name.from-identifier("warn")
        )
      ),
      RakuAST::Statement::Expression.new(
        expression => RakuAST::IntLiteral.new(42)
      )
    );

    plan 5;  # additional tests here that need to pass
    is-deeply $deparsed,
      qq:!s:!c|CONTROL {\n    isa-ok($_, CX::Warn);\n    .resume()\n}\nwarn();\n42\n|,
      'deparse';

    is-deeply $_, 42, @type[$++]
      for EVAL($ast), EVAL($deparsed);
}

subtest 'CATCH phaser catching an exception' => {
    # CATCH {
    #     isa-ok $_, X::AdHoc
    #     .resume
    # }
    # die();
    # 42
    ast RakuAST::StatementList.new(
      RakuAST::Statement::Catch.new(
        body => RakuAST::Block.new(
          body => RakuAST::Blockoid.new(
            RakuAST::StatementList.new(
              RakuAST::Statement::Expression.new(
                expression => RakuAST::Call::Name.new(
                  name => RakuAST::Name.from-identifier("todo"),
                  args => RakuAST::ArgList.new(
                    RakuAST::StrLiteral.new("Getting a warning instead of an exception???")
                  )
                )
              ),
              RakuAST::Statement::Expression.new(
                expression => RakuAST::Call::Name.new(
                  name => RakuAST::Name.from-identifier("isa-ok"),
                  args => RakuAST::ArgList.new(
                    RakuAST::Var::Lexical.new('$_'),
                    RakuAST::Type::Simple.new(
                      RakuAST::Name.from-identifier-parts('X', 'AdHoc')
                    )
                  )
                )
              ),
              RakuAST::Statement::Expression.new(
                expression => RakuAST::Term::TopicCall.new(
                  RakuAST::Call::Method.new(
                    name => RakuAST::Name.from-identifier("resume")
                  )
                )
              )
            )
          )
        )
      ),
      RakuAST::Statement::Expression.new(
        expression => RakuAST::Call::Name.new(
          name => RakuAST::Name.from-identifier("die")
        )
      ),
      RakuAST::Statement::Expression.new(
        expression => RakuAST::IntLiteral.new(666)
      )
    );

    plan 5;  # additional tests here that need to pass
    is-deeply $deparsed, qq:!s:!c:to/CODE/, 'deparse';
CATCH {
    todo("Getting a warning instead of an exception???");
    isa-ok($_, X::AdHoc);
    .resume()
}
die();
666
CODE

    is-deeply $_, 666, @type[$++]
      for EVAL($ast), EVAL($deparsed);
}

subtest 'LEAVE phaser thunk being run' => {
    my $done = 666;

    # { $done = False; LEAVE pass("leaving"); $done = True }
    ast RakuAST::Block.new(
      body => RakuAST::Blockoid.new(
        RakuAST::StatementList.new(
          RakuAST::Statement::Expression.new(
            expression => RakuAST::ApplyInfix.new(
              left  => RakuAST::Var::Lexical.new('$done'),
              infix => RakuAST::Infix.new('='),
              right => RakuAST::Term::False.new
            )
          ),
          RakuAST::Statement::Expression.new(
            expression => RakuAST::StatementPrefix::Phaser::Leave.new(
              RakuAST::Statement::Expression.new(
                expression => RakuAST::Call::Name.new(
                  name => RakuAST::Name.from-identifier("pass"),
                  args => RakuAST::ArgList.new(
                    RakuAST::StrLiteral.new("leaving")
                  )
                )
              )
            )
          ),
          RakuAST::Statement::Expression.new(
            expression => RakuAST::ApplyInfix.new(
              left  => RakuAST::Var::Lexical.new('$done'),
              infix => RakuAST::Infix.new('='),
              right => RakuAST::Term::True.new
            )
          )
        )
      )
    );

    plan 7;  # additional tests here that need to pass
    is-deeply $deparsed, qq:!c:!s:to/CODE/, 'deparse';
{
    $done = False;
    LEAVE pass("leaving");
    $done = True
}
CODE

    for 'AST', $ast, 'Str', $deparsed -> $type, $it {
        is-deeply EVAL($it), True, "$type: result correct";
        is-deeply $done, True, "$type: did block run to completion";
    }
}

subtest 'LEAVE phaser block being run' => {
    my $done = 666;

    # { $done = False; LEAVE { pass("leaving") }; $done = True }
    ast RakuAST::Block.new(
      body => RakuAST::Blockoid.new(
        RakuAST::StatementList.new(
          RakuAST::Statement::Expression.new(
            expression => RakuAST::ApplyInfix.new(
              left  => RakuAST::Var::Lexical.new('$done'),
              infix => RakuAST::Infix.new('='),
              right => RakuAST::Term::False.new
            )
          ),
          RakuAST::Statement::Expression.new(
            expression => RakuAST::StatementPrefix::Phaser::Leave.new(
              RakuAST::Block.new(
                body => RakuAST::Blockoid.new(
                  RakuAST::StatementList.new(
                    RakuAST::Statement::Expression.new(
                      expression => RakuAST::Call::Name.new(
                        name => RakuAST::Name.from-identifier("pass"),
                        args => RakuAST::ArgList.new(
                          RakuAST::StrLiteral.new("leaving")
                        )
                      )
                    )
                  )
                )
              )
            )
          ),
          RakuAST::Statement::Expression.new(
            expression => RakuAST::ApplyInfix.new(
              left  => RakuAST::Var::Lexical.new('$done'),
              infix => RakuAST::Infix.new('='),
              right => RakuAST::Term::True.new
            )
          )
        )
      )
    );

    plan 7;  # additional tests here that need to pass
    is-deeply $deparsed, qq:!c:!s:to/CODE/, 'deparse';
{
    $done = False;
    LEAVE {
        pass("leaving")
    }
    $done = True
}
CODE

    for 'AST', $ast, 'Str', $deparsed -> $type, $it {
        is-deeply EVAL($it), True, "$type: result correct";
        is-deeply $done, True, "$type: did block run to completion";
    }
}

subtest 'END phaser thunk being run' => {
    # END pass("leaving END thunk")
    ast RakuAST::StatementPrefix::Phaser::End.new(
      RakuAST::Statement::Expression.new(
        expression => RakuAST::Call::Name.new(
         name => RakuAST::Name.from-identifier("pass"),
          args => RakuAST::ArgList.new(
            RakuAST::StrLiteral.new("leaving END thunk")
          )
        )
      )
    );

    is-deeply $deparsed, qq:!c/END pass("leaving END thunk")/, 'deparse';

    is-deeply $_, Nil, @type[$++]
      for EVAL($ast), EVAL($deparsed);
}

subtest 'END phaser block being run' => {
    # END { pass("leaving END block") }
    ast RakuAST::StatementPrefix::Phaser::End.new(
      RakuAST::Block.new(
        body => RakuAST::Blockoid.new(
          RakuAST::StatementList.new(
            RakuAST::Statement::Expression.new(
              expression => RakuAST::Call::Name.new(
                name => RakuAST::Name.from-identifier("pass"),
                args => RakuAST::ArgList.new(
                  RakuAST::StrLiteral.new("leaving END block")
                )
              )
            )
          )
        )
      )
    );

    is-deeply $deparsed, qq:!c:to/CODE/, 'deparse';
END {
    pass("leaving END block")
}
CODE

    is-deeply $_, Nil, @type[$++]
      for EVAL($ast), EVAL($deparsed);
}

todo("AST FIRST phaser not working yet");
subtest 'For loop with FIRST phaser thunk' => {
    my $run;

    # for ^3 { FIRST is-deeply $run, 0, "inside FIRST"; ++$run }
    ast RakuAST::Statement::For.new(
      source => RakuAST::ApplyPrefix.new(
        prefix  => RakuAST::Prefix.new('^'),
        operand => RakuAST::IntLiteral.new(3)
      ),
      body => RakuAST::Block.new(
        body => RakuAST::Blockoid.new(
          RakuAST::StatementList.new(
            RakuAST::Statement::Expression.new(
              expression => RakuAST::StatementPrefix::Phaser::First.new(
                RakuAST::Statement::Expression.new(
                  expression => RakuAST::Call::Name.new(
                    name => RakuAST::Name.from-identifier("is-deeply"),
                    args => RakuAST::ArgList.new(
                      RakuAST::Var::Lexical.new('$run'),
                      RakuAST::IntLiteral.new(0),
                      RakuAST::StrLiteral.new('inside FIRST'),
                    )
                  )
                )
              )
            ),
            RakuAST::Statement::Expression.new(
              expression => RakuAST::ApplyPrefix.new(
                prefix => RakuAST::Prefix.new('++'),
                operand => RakuAST::Var::Lexical.new('$run')
              )
            )
          )
        )
      )
    );

    plan 5;  # FIRST tests need to be run
    is-deeply $deparsed, Q:to/CODE/, 'deparse';
for ^3 {
    FIRST is-deeply($run, 0, "inside FIRST");
    ++$run
}
CODE

    for 'AST', $ast, 'Str', $deparsed -> $type, $it {
        $run = 0;

        is-deeply EVAL($it), Nil, "$type: for loop evaluates to Nil";
    }
}

todo("AST FIRST phaser not working yet");
subtest 'For loop with FIRST phaser block' => {
    my $run;

    # for ^3 { FIRST { is-deeply $run, 0, "inside FIRST" }; ++$run }
    ast RakuAST::Statement::For.new(
      source => RakuAST::ApplyPrefix.new(
        prefix  => RakuAST::Prefix.new('^'),
        operand => RakuAST::IntLiteral.new(3)
      ),
      body => RakuAST::Block.new(
        body => RakuAST::Blockoid.new(
          RakuAST::StatementList.new(
            RakuAST::Statement::Expression.new(
              expression => RakuAST::StatementPrefix::Phaser::First.new(
                RakuAST::Block.new(
                  body => RakuAST::Blockoid.new(
                    RakuAST::StatementList.new(
                      RakuAST::Statement::Expression.new(
                        expression => RakuAST::Call::Name.new(
                          name => RakuAST::Name.from-identifier("is-deeply"),
                          args => RakuAST::ArgList.new(
                            RakuAST::Var::Lexical.new('$run'),
                                  RakuAST::IntLiteral.new(0),
                            RakuAST::StrLiteral.new('inside FIRST'),
                          )
                        )
                      )
                    )
                  )
                )
              )
            ),
            RakuAST::Statement::Expression.new(
              expression => RakuAST::ApplyPrefix.new(
                prefix => RakuAST::Prefix.new('++'),
                operand => RakuAST::Var::Lexical.new('$run')
              )
            )
          )
        )
      )
    );

    plan 5;  # FIRST tests need to be run
    is-deeply $deparsed, Q:to/CODE/, 'deparse';
for ^3 {
    FIRST {
        is-deeply($run, 0, "inside FIRST")
    }
    ++$run
}
CODE

    for 'AST', $ast, 'Str', $deparsed -> $type, $it {
        $run = 0;

        is-deeply EVAL($it), Nil, "$type: for loop evaluates to Nil";
    }
}

subtest 'For loop with NEXT / LAST phaser thunk' => {
    my $next;
    my $last;

    # for ^3 { NEXT ++$next; LAST ++$last }
    ast RakuAST::Statement::For.new(
      source => RakuAST::ApplyPrefix.new(
        prefix  => RakuAST::Prefix.new('^'),
        operand => RakuAST::IntLiteral.new(3)
      ),
      body => RakuAST::Block.new(
        body => RakuAST::Blockoid.new(
          RakuAST::StatementList.new(
            RakuAST::Statement::Expression.new(
              expression => RakuAST::StatementPrefix::Phaser::Next.new(
                RakuAST::Statement::Expression.new(
                  expression => RakuAST::ApplyPrefix.new(
                    prefix => RakuAST::Prefix.new('++'),
                    operand => RakuAST::Var::Lexical.new('$next')
                  )
                )
              )
            ),
            RakuAST::Statement::Expression.new(
              expression => RakuAST::StatementPrefix::Phaser::Last.new(
                RakuAST::Statement::Expression.new(
                  expression => RakuAST::ApplyPrefix.new(
                    prefix => RakuAST::Prefix.new('++'),
                    operand => RakuAST::Var::Lexical.new('$last')
                  )
                )
              )
            )
          )
        )
      )
    );
    is-deeply $deparsed, Q:to/CODE/, 'deparse';
for ^3 {
    NEXT ++$next;
    LAST ++$last
}
CODE

    for 'AST', $ast, 'Str', $deparsed -> $type, $it {
        $next = $last = 0;

        is-deeply EVAL($it), Nil, "$type: for loop evaluates to Nil";
        is-deeply $next, 3, "$type: NEXTed expected number of times";
        is-deeply $last, 1, "$type: LASTed expected number of times";
    }
}

subtest 'For loop with NEXT phaser block' => {
    my $next;
    my $last;

    # for ^3 { NEXT { ++$next }; LAST { ++$last } }
    ast RakuAST::Statement::For.new(
      source => RakuAST::ApplyPrefix.new(
        prefix  => RakuAST::Prefix.new('^'),
        operand => RakuAST::IntLiteral.new(3)
      ),
      body => RakuAST::Block.new(
        body => RakuAST::Blockoid.new(
          RakuAST::StatementList.new(
            RakuAST::Statement::Expression.new(
              expression => RakuAST::StatementPrefix::Phaser::Next.new(
                RakuAST::Block.new(
                  body => RakuAST::Blockoid.new(
                    RakuAST::StatementList.new(
                      RakuAST::Statement::Expression.new(
                        expression => RakuAST::ApplyPrefix.new(
                          prefix => RakuAST::Prefix.new('++'),
                          operand => RakuAST::Var::Lexical.new('$next')
                        )
                      )
                    )
                  )
                )
              )
            ),
            RakuAST::Statement::Expression.new(
              expression => RakuAST::StatementPrefix::Phaser::Last.new(
                RakuAST::Block.new(
                  body => RakuAST::Blockoid.new(
                    RakuAST::StatementList.new(
                      RakuAST::Statement::Expression.new(
                        expression => RakuAST::ApplyPrefix.new(
                          prefix => RakuAST::Prefix.new('++'),
                          operand => RakuAST::Var::Lexical.new('$last')
                        )
                      )
                    )
                  )
                )
              )
            )
          )
        )
      )
    );
    is-deeply $deparsed, Q:to/CODE/, 'deparse';
for ^3 {
    NEXT {
        ++$next
    }
    LAST {
        ++$last
    }
}
CODE

    for 'AST', $ast, 'Str', $deparsed -> $type, $it {
        $next = $last = 0;

        is-deeply EVAL($it), Nil, "$type: for loop evaluates to Nil";
        is-deeply $next, 3, "$type: NEXTed expected number of times";
        is-deeply $last, 1, "$type: LASTed expected number of times";
    }
}

# vim: expandtab shiftwidth=4
