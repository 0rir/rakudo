## $Id$

=head1 RAKUDO COMPILER OVERVIEW

=head2 How the Rakudo Perl 6 compiler works

This document describes the architecture and operation of the Rakudo
Perl 6 (or simply Rakudo) compiler.  The F<README> describes how to
build and run Rakudo.

Rakudo has six main parts summarized below.  Source code paths are
relative to Rakudo's F<src/> directory, and platform specific filename
extensions such as F<.exe> are sometimes omitted for brevity.

=over 4

=item 1.

Not Quite Perl builds Perl 6 source code parts into Rakudo

=item 2.

A main program drives parsing, code generation and runtime execution
(F<Perl6/Compiler.pir>)

=item 3.

A grammar parses user programs (F<Perl6/Grammar.pm>)

=item 4.

Action methods build a Parrot Abstract Syntax Tree (F<Perl6/Actions.pm>)

=item 5.

Parrot extensions provide Perl 6 run time behavior (TODO: describe)
(F<binder/*>, F<ops/*>, F<pmc/*>)

=item 6.

Libraries provide functions at run time (F<builtins/*.pir>, F<cheats/*>,
F<core/*.pm>, F<glue/*.pir>, F<metamodel/*>)

=back

The F<Makefile> (generated from F<build/Makefile.in> by
F<../Configure.pl>) compiles all the parts to form the F<perl6.pbc>
executable and the F<perl6> or F<perl6.exe> "fake executable".  We call
it fake because it has only a small stub of code to launch the Parrot
executable, and passes itself as a chunk of bytecode for Parrot to
execute.  The source code of the "fakecutable" is generated as
F<perl6.c> with the stub at the very end.  The entire contents of
F<perl6.pbc> are represented as escaped octal characters in one huge
string called C<program_code>.  What a hack!

=head2 1. NQP[-RX]

The source files of Rakudo are preferably and increasingly written in
Perl 6, the remainder in Parrot Intermediate Representation (PIR) or C.
Not Quite Perl (nqp) provides the bootstrap step of compiling compiler
code (yes!) written in a subset of Perl 6, into PIR.

The latest version of NQP is called B<nqp-rx> because it now also
includes a powerful Perl 6 regex engine.  This gives a streamlined
compiler framework on which to build a very functional Perl 6
implementation.

NQP itself is also written in PIR, is an important part of the Parrot
Compiler Toolkit (PCT), and is installed with Parrot.  PCT is a standard
framework to make and use Parrot based languages.  The source code of
NQP is in F<../parrot/ext/nqp-rx/> and the resulting compiler is
F<../parrot_install/bin/parrot-nqp>.  Note, NQP only I<builds> the
Rakudo compiler, and does not compile or run user programs.

=head3 Stages

NQP[-RX] compiles us a very good compiler in F<gen/perl6.pbc>, referred
to as "stage-1", or C<S1_PERL6_PBC> in the F<Makefile>.  This version
would be limited in production though, because libraries of classes and
methods available at run time (for example Complex) have not yet been
added.

The "stage-1" compiler (note: not NQP) compiles all Rakudo's Perl 6 code
again, this time including all the library modules (F<gen/core.pm>), to
make F<perl6.pbc> (note: not in F<gen/>).  That F<gen/core.pm> file is
generated by F<build/gen_core_pm.pl> from a list called C<CORE_SOURCES>
in F<Makefile>.  Thanks to the staging process, a large and growing
proportion of Rakudo's source code is written in Perl 6.

We can conceivably use the Rakudo compiler to compile itself to PIR and
eliminate the need for NQP entirely.  At some point as Rakudo matures we
will probably do this.  However, for the time being it's slightly easier
to manage the process if we keep a distinction between the two tools,
and using NQP for this stage also helps us to limit ourselves to using a
regular, well-defined, and relatively easy-to-implement subset of Perl 6
for the core compiler.  So, while it's possible for us to eliminate NQP
from the process, there are some good reasons not to do so just yet.
(If at some point we discover that we need something for the compiler
that NQP can't or won't support, then that will probably be a good point
to switch.)

=head2 2. Compiler main program

A subroutine called C<'main'>, in F<Perl6/Compiler.pir>, starts the
source parsing and bytecode generation work.  It creates a
C<Perl6::Compiler> object for the C<'perl6'> source type.  The
C<Perl6::Compiler> class inherits from the C<HLLCompiler> class of the
Parrot Compiler Toolkit, look in
F<../parrot/compilers/pct/src/PCT/HLLCompiler.pir>.

Before tracing Rakudo's execution further, a few words about Parrot
process and library initialization.

Parrot execution does not simply begin with 'main'.  When Parrot
executes a bytecode file, it first calls all subroutines in it that are
marked with the C<:init> modifier.  Rakudo has over 50 such subroutines,
brought in by C<.include> directives in F<Perl6/Compiler.pir>, to create
classes and objects in Parrot's memory.

Similarly, when the executable loads libraries, Parrot automatically
calls subs having the C<:load> modifier.  The Rakudo C<:init> subs are
usually also C<:load>, so that the same startup sequence occurs whether
Rakudo is run as an executable or loaded as a library.

F<Perl6/Compiler.pir> has three C<.loadlib> commands early on, for
C<perl6_group>, C<perl6_ops> and C<math_ops>.  All three dynamically
extend Parrot with respectively Rakudo specific PMC's (Poly Morphic
Containers, formerly Parrot Magic Cookies), opcodes, and mathematical
operators.  The source is in F<pmc/*>, F<ops/*> and
F<parrot/src/ops/math.ops>.

So, that Rakudo 'main' subroutine had created a C<Perl6::Compiler>
object.  Next, 'main' invokes the C<'command_line'> method on this
object, passing the command line arguments in a PMC called C<args_str>.
The C<'command_line'> method is inherited from the C<HLLCompiler> parent
class (part of the PCT, remember).

And that's it, apart from a C<'!fire_phasers'('END')> and an C<exit>.
Well, as far a C<'main'> is concerned.  The remaining work is divided
between PCT, grammar and actions.

=head2 2. Grammar

Using C<parrot-nqp>, C<make> target C<PERL6_G> uses F<parrot-nqp> to
compile F<Perl6/Grammar.pm> to F<gen/perl6-grammar.pir>.

The top-level portion of the grammar is written using Perl 6 rules
(Synopsis 5) and is based on the STD.pm grammar in the Pugs repository
(L<http://svn.pugscode.org/pugs/src/perl6/STD.pm>).  There are a few
places where Rakudo's grammar deviates from STD.pm, but the ultimate
goal is for the two to converge.  The grammar inherits from
C<HLL::Grammar>, which provides the C<< <.panic> >> rule to throw
exceptions for syntax errors.

The compiler works by calling C<TOP> method in F<Perl6/Grammar.pm>.
After some initialization, TOP matches the user program to the comp_unit
(meaning compilation unit) token.  That triggers a series of matches to
other tokens and rules (two kinds of regex) depending on the source in
the user program.

=head2 3. Actions

The F<Perl6/Actions.pm> file defines the code that the compiler
generates when it matches each token or rule.  The output is a tree
hierarchy of objects representing language syntax elements, such as a
statement.  The tree is called a Parrot Abstract Syntax Tree (PAST).

The C<Perl6::Actions> class inherits from C<HLL::Actions>, another part
of the Parrot Compiler Toolkit.  The source is in
F<../parrot/ext/nqp-rx/stage0/src/HLL-s0.pir>, look for several
instances of C<.namespace ["HLL";"Actions"]>.

When the PCT calls the C<'parse'> method on a grammar, it passes not
only the program source code, but also a pointer to a parseactions class
such as our compiled C<Perl6::Actions>.  Then, each time the parser
matches a named regex in the grammar, it automatically calls the same
named method in the actions class.

For example, here's the parse rule for Rakudo's C<unless> statement
(in F<Perl6/Grammar.pm>):

 token statement_control:sym<unless> {
   <sym> :s
   <xblock>
   [ <!before 'else'> ||
     <.panic: 'unless does not take "else", please rewrite using "if"'>
   ]
 }

This token says that an C<unless> statement consists of the word
"unless" (captured into C<< $<sym> >>), and then an expression followed
by a block.  If that all matches, the parser invokes the corresponding
action method for C<< statement_control:sym<unless> >>.

Remember that for a match, not only must the C<< <sym> >> match the word
C<unless>, the C<< <xblock> >> must also match the C<xblock> token.  If
you read more of F<Perl6/Grammar.pm>, you will learn that C<xblock> in
turn tries to match an C<< <EXPR> >> and a C<< <pblock>  >>, which in
turn tries to match .....

This is why parsing source code this way is called Recursive Descent.

Back to the C<unless> example, here's the action method for the
C<unless> statement (from F<Perl6/Actions.pm>):

 method statement_control:sym<unless>($/) {
   my $past := xblock_immediate( $<xblock>.ast );
   $past.pasttype('unless');
   make $past;
 }

When the parser invokes this action method, the current match object
containing the parsed statement is passed into the method as C<$/>.
In Perl 6, this means that the expression C<< $<xblock> >> refers to
whatever the parser matched to the C<xblock> token.  Similarly there
are C<< $<EXPR> >> and C<< $<pblock> >> objects etc until the end of the
recursive descent.  By the way, C<< $<xblock> >> is Perl 6 syntactic
sugar for C< $/{'xblock'} >.

The magic occurs in the C<< $<xblock>.ast >> and C<make> expressions in
the method body.  The C<.ast> method retrieves the PAST made already for
the C<xblock> subtree.  Thus C<$past> becomes a node object describing
code to conditionally execute the block in the subtree.

The C<make> statement at the end of the method sets the newly created
C<xblock_immediate> node as the PAST representation of the unless
statement that was just parsed.

The Parrot Compiler Toolkit provides a wide variety of PAST node types
for representing the various components of a HLL program -- for more
details about the available node types, see PDD 26
(L<http://svn.parrot.org/parrot/trunk/docs/pdds/pdd26_ast.pod>).

The PAST representation is the final stage of processing in Rakudo
itself.  The PAST data structure is then passed on to Parrot directly.
Parrot does the remainder of the work translating from PAST to pir and
then to bytecode.

--- ng update progress point

Lastly, the F<src/parser/quote_expression.pir> file implements
code to parse the various forms of Perl 6 quoting rules.  It's
far easier to write this component using PIR instead of a
regular expression, but otherwise it acts just like any other
rule in the grammar.

=head2 6. Builtin functions and runtime support

The last component of the compiler are the various builtin
functions and libraries that a Perl 6 program expects to
have available when it is running.  These include functions
for the basic operations (C<< infix:<+> >>, C<< prefix:<abs> >>)
as well as common global functions such as C<say> and C<print>.

=head2 Still to be documented

    * Rakudo PMCs
    * The relationship between Parrot classes and Rakudo classes
    * Protoobject implementation and basic class hierarchy

=head1 AUTHORS

Patrick Michaud <pmichaud@pobox.com> is the primary author and
maintainer of Rakudo.  The other contributors and named in F<CREDITS>.

=head1 COPYRIGHT

Copyright (C) 2007-2009, The Perl Foundation.

=cut

# Local Variables:
#   fill-column: 100
# End:
# vim: expandtab shiftwidth=4:
