=head1 Custom Metaclasses And Rakudo

=head2 Warning

What follows is the current way this works in Rakudo. Parts of it may one day
become spec, other bits likely never will. All of it is liable to change as we
work out what should be spec and what shouldn't be, and also co-ordinate with
other implementations and interested parties to make sure those bits that we
determine should be specification are spec'd in a way that matches our shared
desires and needs, so far as that's possible. It goes without saying that in
doing the things described in this document, you're walking barefoot through a
construction site. For now, tread carefully, and be prepared to patch up in
response to changes.

=head2 Associating a scope declarator with metaclass

Rakudo provides two levels of hookage for creating new types of scope
declarator. You will very likely only need this one, which is the HOW map,
%*HOW. This is simply a hash that maps the name of a scope declarator to the
name of the HOW to create. At the entry point to your derived grammar, you
should temporize the curent HOW hash from the calling language, and add
mappings from names of package declarators that you will introduce to the HOW
to use. By default, this hash contains things like:

    { class => 'ClassHOW',role => 'RoleHOW' }
    
It's completely fine for multiple package declarators to map to the same HOW
- you may just wish to introduce a new one as better documentation but not
need to do anything more special in terms of the meta-model. Note that your
rule for parsing the scope declarator sets the name of the thing in this map
in the $*PKGDECL global. For example, here is one from STD.

  token package_declarator:role {
      :my $*PKGDECL ::= 'role';
      <sym> <package_def>
  }

You should do the same (and it's probably nice if what you set matches the
name of the symbol you parse).

=head2 Influencing code generation

This second part is highly Rakudo specific and very likely to remain that way.
The good news is that you won't need to do it often. Rakudo has a compile-time
representation of a package that it is currently in the process of compiling.
This is the thing that ends up actually generating the code - PAST nodes - that
make the calls on the metaclass. By default, we always create an instance of
Perl6::Compiler::Package, apart from for roles and modules, for which we need
to do some slightly different code generation for - those use a subclass of it,
such as Perl6::Compiler::Role. You may modify %*PKGCOMPILER, again keying on
the scope, to specify something other than the default. You then should write
a subclass of an existing handler for this and implement the same interface
(plus any other bits you'll need - it's just a class).

=head2 Implementing a HOW

The HOW API for Rakudo quite often agrees with the one proposed by the SMOP
project, but they are not yet entirely compatible. This part is something we
highly desire to become part of the Perl 6 specification at some point, but
for now it's still subject to change.

Basically, your HOW should implement the following methods.

=over 4

=item method new($name?)

Creates a new instance of the thing we're going to operate on to declare a new
package. This is usually just the type of the invocant, since for a class-based
OO system you'd have the metaclass holding the details of the class, and if it's
a prototype based one then you'd register your most basic prototype as the HOW.
If you need to do something different, you may return something else here, though.

=item add_method($meta, $name, &code_ref)

Adds a method to the methods table of C<$meta> under the given C<$name> and with
the given implementation.

=item compose($meta)

This returns the the type object that we're going to actually install into the
namespace or lexical pad or just return if it's an anonymous declaration. It
can do any other composition time operations, such as role composition and
checking for composition conflicts.

=back
