/*
 * Copyright (C) 2008-2011, The Perl Foundation.
 */

BEGIN_OPS_PREAMBLE

#include "parrot/parrot.h"
#include "parrot/extend.h"
#include "parrot/dynext.h"
#include "pmc_object.h"
#include "pmc_class.h"
#include "pmc_callcontext.h"
#include "pmc_sub.h"
#include "../binder/bind.h"
#include "../binder/multidispatch.h"
#include "../binder/container.h"
#include "../binder/types.h"
#include "../binder/sixmodelobject.h"

#if PARROT_HAS_ICU
#  include <unicode/uchar.h>
#endif

/* Cache some stuff for fast access. */
static INTVAL smo_id = 0;
static STRING *DISPATCH_JUNCTION_str;

END_OPS_PREAMBLE

/*

=item rakudo_dynop_setup()

Does various setup tasks on behalf of all of the other dynops.

=cut

*/
inline op rakudo_dynop_setup() :base_core {
    smo_id = pmc_type(interp, Parrot_str_new(interp, "SixModelObject", 0));
    DISPATCH_JUNCTION_str = Parrot_str_new_constant(interp,
                                "!DISPATCH_JUNCTION_SINGLE");
}

/*

=item find_lex_skip_current(out PMC, in STR)

Finds the lexical named $2 and returns it. However, unlike find_lex this op
skips the current sub and starts looking immediately at its outers.

=cut

*/
inline op find_lex_skip_current(out PMC, in STR) :base_core {
    PMC *ctx = CURRENT_CONTEXT(interp);
    $1 = PMCNULL;

    while (Parrot_pcc_get_outer_ctx(interp, ctx)) {
        PMC   * const outer   = Parrot_pcc_get_outer_ctx(interp, ctx);
        PMC   * const lex_pad = Parrot_pcc_get_lex_pad(interp, outer);

        if (!PMC_IS_NULL(lex_pad) && VTABLE_exists_keyed_str(interp, lex_pad, $2)) {
            $1 = VTABLE_get_pmc_keyed_str(interp, lex_pad, $2);
            break;
        }

        ctx = outer;
    }
}


/*

=item inline op x_is_uprop(out INT, in STR, in STR, in INT)

Sets a true value in $1 if character $4 in string $3 has the unicode property
named $2.

=cut

*/
inline op x_is_uprop(out INT, in STR, in STR, in INT) :base_core {
#if PARROT_HAS_ICU
    char     *cstr;
    INTVAL    ord;
    int32_t   strwhich, ordwhich;
    UProperty strprop;
    opcode_t  *handler;

    if ($4 > 0 && (UINTVAL)$4 == ($3->strlen)) {
        $1 = 0;
        goto NEXT();
    }

    ord = Parrot_str_indexed(interp, $3, $4);
    cstr = Parrot_str_to_cstring(interp, $2);

    /* try block tests */
    if (strncmp(cstr, "In", 2) == 0) {
        strwhich = u_getPropertyValueEnum(UCHAR_BLOCK, cstr+2);
        ordwhich = u_getIntPropertyValue(ord, UCHAR_BLOCK);
        if (strwhich != UCHAR_INVALID_CODE) {
            $1 = (strwhich == ordwhich);
            Parrot_str_free_cstring(cstr);
            goto NEXT();
        }
    }

    /* try bidi tests */
    if (strncmp(cstr, "Bidi", 4) == 0) {
        strwhich = u_getPropertyValueEnum(UCHAR_BIDI_CLASS, cstr+4);
        ordwhich = u_getIntPropertyValue(ord, UCHAR_BIDI_CLASS);
        if (strwhich != UCHAR_INVALID_CODE) {
            $1 = (strwhich == ordwhich);
            Parrot_str_free_cstring(cstr);
            goto NEXT();
        }
    }

    /* try property value aliases */
    strwhich = u_getPropertyValueEnum(UCHAR_GENERAL_CATEGORY_MASK, cstr);
    if (strwhich != UCHAR_INVALID_CODE) {
        ordwhich = u_getIntPropertyValue(ord, UCHAR_GENERAL_CATEGORY_MASK);
        $1 = ((strwhich & ordwhich) != 0);
        Parrot_str_free_cstring(cstr);
        goto NEXT();
    }

    /* try property */
    strprop = u_getPropertyEnum(cstr);
    if (strprop != UCHAR_INVALID_CODE) {
        $1 = (u_hasBinaryProperty(ord, strprop) != 0);
        Parrot_str_free_cstring(cstr);
        goto NEXT();
    }

    /* try script aliases */
    strwhich = u_getPropertyValueEnum(UCHAR_SCRIPT, cstr);
    if (strwhich != UCHAR_INVALID_CODE) {
        ordwhich = u_getIntPropertyValue(ord, UCHAR_SCRIPT);
        $1 = (strwhich == ordwhich);
        Parrot_str_free_cstring(cstr);
        goto NEXT();
    }

    /* unrecognized property name */
    Parrot_str_free_cstring(cstr);
    handler =  Parrot_ex_throw_from_op_args(interp, NULL,
            EXCEPTION_ICU_ERROR,
            "Unicode property '%Ss' not found", $2);
    goto ADDRESS(handler);
#else
    opcode_t * const handler = Parrot_ex_throw_from_op_args(interp, NULL,
            EXCEPTION_ICU_ERROR,
            "ICU not loaded", $2);
    goto ADDRESS(handler);
#endif
}


/*

=item get_next_candidate_info(out PMC, out PMC, out PMC)

Looks through the outers of our caller, until we find a Routine, for a lexical
named __CANDIDATE_LIST__. Hands this lexical back in $1, the PMC for the Routine
it was found in as $2 and the lexpad of that routine as $3. This is a fairly
special-purpose op that does just what callwith, callsame, nextwith and
nextsame need.

=cut

*/
inline op get_next_candidate_info(out PMC, out PMC, out PMC) :base_core {
    PMC     *ctx         = Parrot_pcc_get_caller_ctx(interp, CURRENT_CONTEXT(interp));
    STRING  * const name = Parrot_str_new(interp, "__CANDIDATE_LIST__", 0);

    while (!PMC_IS_NULL(ctx)) {
        /* See if we've found a candidate list. */
        PMC * const lexpad = Parrot_pcc_get_lex_pad(interp, ctx);
        PMC * const clist  = VTABLE_get_pmc_keyed_str(interp, lexpad, name);
        if (!PMC_IS_NULL(clist)) {
            /* Found. Set results and we're done. */
            $1 = clist;
            $2 = Parrot_pcc_get_sub(interp, ctx);
            $3 = lexpad;
            break;
        }
        else {
            /* Not found; keep looking. */
            ctx = Parrot_pcc_get_outer_ctx(interp, ctx);
        }
    }
    if (!ctx)
        $1 = $2 = $3 = PMCNULL;

    goto NEXT();
}


/*

=item bind_signature(in PMC)

This is emitted into a sub to cause it's Perl 6 signature to be bound. $1 is
the signature to bind against. The current call context is used to find the
arguments.

=cut

*/
inline op bind_signature(in PMC) :base_core {
    PMC * const ctx = CURRENT_CONTEXT(interp);

    /* If we aren't already bound, enter the appropriate binder. */
    if (!PObj_flag_TEST(P6S_ALREADY_BOUND, ctx)) {
        /* Need to make sure some stuff doesn't get destroyed. */
        PMC      * const saved_ccont = interp->current_cont;
        PMC      * const saved_sig   = Parrot_pcc_get_signature(interp, ctx);
        opcode_t * const current_pc  = Parrot_pcc_get_pc(interp, ctx);
        
        /* Obtain lexpad and other settings. */
        PMC * const lexpad        = Parrot_pcc_get_lex_pad(interp, ctx);
        const INTVAL noms_checked = PObj_flag_TEST(P6S_ALREADY_CHECKED, ctx);
        STRING * error            = STRINGNULL;
        INTVAL bind_error;

        /* Call signature binder. */
        bind_error = Rakudo_binding_bind(interp, lexpad, $1, ctx, noms_checked, &error);

        /* Bind ok? */
        if (!bind_error) {
            /* Re-instate anything we may have damaged. */
            CURRENT_CONTEXT(interp) = ctx;
            interp->current_cont    = saved_ccont;
            Parrot_pcc_set_signature(interp, ctx, saved_sig);
            Parrot_pcc_set_pc(interp, ctx, current_pc);
            goto NEXT();
        }
        else {
            /* Maybe we need to auto-thread... */
            if (bind_error == BIND_RESULT_JUNCTION) {
                /* Find dispatcher and call it. */
                PMC * const returns    = Parrot_pmc_new(interp, enum_class_CallContext);
                PMC * const dispatcher = Parrot_ns_find_namespace_global(interp, Parrot_hll_get_ctx_HLL_namespace(interp), DISPATCH_JUNCTION_str);
                PMC * const sub        = Parrot_pcc_get_sub(interp, ctx);
                opcode_t *next;
                PMC *junc_result;
                
                Parrot_ext_call(interp, dispatcher, "PP->P", sub, ctx, &junc_result);

                /* Build call signautre of returns and set it. */
                VTABLE_push_pmc(interp, returns, junc_result);
                Parrot_pcc_set_signature(interp, CURRENT_CONTEXT(interp), returns);

                /* Invoke the current return continuation, to return said value. */
                next = VTABLE_invoke(interp, Parrot_pcc_get_continuation(interp,
                        CURRENT_CONTEXT(interp)), expr NEXT());
                goto ADDRESS(next);
            }
            else {
                /* Nope, just normal fail... */
                opcode_t * const handler = Parrot_ex_throw_from_op_args(interp, NULL,
                        EXCEPTION_INVALID_OPERATION, "%Ss", error);
                goto ADDRESS(handler);
            }
        }
    }
    else {
        goto NEXT();
    }
}


/*

=item perl6_set_type_mu(in PMC)

Sets the top type.

=cut

*/
inline op perl6_set_type_mu(in PMC) :base_core {
    Rakudo_types_mu_set($1);
}


/*

=item perl6_set_type_junction(in PMC)

Sets the junction type.

=cut

*/
inline op perl6_set_type_junction(in PMC) :base_core {
    Rakudo_types_junction_set($1);
}


/*

=item perl6_set_types_ins(in PMC, in PMC, in PMC)

Sets the Int/Num/Str types.

=cut

*/
inline op perl6_set_types_ins(in PMC, in PMC, in PMC) :base_core {
    Rakudo_types_int_set($1);
    Rakudo_types_num_set($2);
    Rakudo_types_str_set($3);
}


/*

=item perl6_booleanize(out PMC, in INT)

If $2 is non-zero, puts Bool::True in $1. Otherwise puts Bool::False
in.

=cut

*/
inline op perl6_booleanize(out PMC, in INT) :base_core {
    $1 = $2 == 0 ? Rakduo_types_bool_false_get() : Rakduo_types_bool_true_get();
}


/*

=item perl6_set_bools(in PMC, in PMC)

Sets and caches the False ($1) and True ($2) values to booleanize to.

=cut

*/
inline op perl6_set_bools(in PMC, in PMC) :base_core {
    Rakudo_types_bool_false_set($1);
    Rakudo_types_bool_true_set($2);
}


/*

=item perl6_box_str()

Box a native string to a Perl 6 Str.

=cut

*/
inline op perl6_box_str(out PMC, in STR) :base_core {
    PMC *type = Rakduo_types_str_get();
    $1 = REPR(type)->instance_of(interp, type);
    REPR($1)->set_str(interp, $1, $2);
}


/*

=item perl6_box_int()

Box a native int to a Perl 6 Int.

=cut

*/
inline op perl6_box_int(out PMC, in INT) :base_core {
    PMC *type = Rakduo_types_int_get();
    $1 = REPR(type)->instance_of(interp, type);
    REPR($1)->set_int(interp, $1, $2);    
}


/*

=item perl6_box_num()

Box a native floating point number to a Perl 6 Num.

=cut

*/
inline op perl6_box_num(out PMC, in NUM) :base_core {
    PMC *type = Rakduo_types_num_get();
    $1 = REPR(type)->instance_of(interp, type);
    REPR($1)->set_num(interp, $1, $2);
}


/*

=item perl6ize_type(out PMC, in PMC)

Looks for Parrot-y types sneaking into Perl 6 land and maps them
into Perl 6 types.

=cut

*/
inline op perl6ize_type(out PMC, in PMC) :base_core {
    if ($2->vtable->base_type == smo_id)
        $1 = $2;
    else
        $1 = Rakudo_types_parrot_map(interp, $2);
}




/*

=item set_scalar_container_type(in PMC)

Sets the scalar container type.

=cut

*/
inline op set_scalar_container_type(in PMC) :base_core {
    Rakudo_cont_set_scalar_type($1);
}


/*

=item perl6_decontainerize(out PMC, in PMC)

Strips away any outer container, if one exists. Otherwise, no-op.

=cut

*/
inline op perl6_decontainerize(out PMC, in PMC) :base_core {
    $1 = Rakudo_cont_decontainerize(interp, $2);
}


/*

=item perl6_container_store(in PMC, in PMC)

Stores a value in a container. If it's Scalar, there's a fast path;
otherwise, calls the .STORE method.

=cut

*/
inline op perl6_container_store(in PMC, in PMC) :base_core {
    Rakudo_cont_store(interp, $1, $2, 1, 1);
}


/*

=item perl6_container_store_unchecked(in PMC, in PMC)

Stores a value in a container. If it's Scalar, there's a fast path;
otherwise, calls the .STORE method. In the fast path case, with this
op no rw or type checking is done (assumes that the compiler has
already decided that it's safe).

=cut

*/
inline op perl6_container_store_unchecked(in PMC, in PMC) :base_core {
    Rakudo_cont_store(interp, $1, $2, 0, 0);
}


/*

=item perl6_assert_bind_ok(in PMC, in PMC)

Takes a potential value to bind in $1 and a container descriptor in $2
and asserts that the bind is allowed to take place.

=cut

*/
inline op perl6_assert_bind_ok(in PMC, in PMC) :base_core {
    if ($1->vtable->base_type == smo_id && $2->vtable->base_type == smo_id) {
        PMC *value = Rakudo_cont_decontainerize(interp, $1);
        PMC *type = ((Rakudo_ContainerDescriptor *)PMC_data($2))->of;
        if (!STABLE(value)->type_check(interp, value, type)) {
            Parrot_ex_throw_from_c_args(interp, NULL, EXCEPTION_INVALID_OPERATION,
                "Type check failed in binding");
        }
    }
    else {
        Parrot_ex_throw_from_c_args(interp, NULL, EXCEPTION_INVALID_OPERATION,
            "Can only use perl6_assert_bind_ok on a SixModelObject");
    }
}


/*

=item find_method_null_ok(out PMC, in PMC, in STR)

Like Parrot's find_method, but returns PMCNULL in $1 if $2 doesn't have a
method named $3 instead of throwing an exception.

=cut

*/
inline op find_method_null_ok(out PMC, in PMC, in STR) :base_core {
    $1 = VTABLE_find_method(interp, $2, $3);
}


/*

=item perl6_enter_multi_dispatch()

Entry point to multi-dispatch over the dispatchee list in the specified
candidate.

=cut

*/
inline op perl6_enter_multi_dispatch_from_onlystar_block(out PMC, in PMC) :base_core {
    PMC *cur_ctx = CURRENT_CONTEXT(interp);
    PMC *chosen  = Rakudo_md_dispatch(interp, $2, cur_ctx, NULL);
    if (!PMC_IS_NULL(chosen)) {
        /* Invoke the chosen candidate; we use the existing call frame
         * and don't make a nested runloop. */
        opcode_t *addr;
        Parrot_pcc_set_signature(interp, cur_ctx, cur_ctx);
        interp->current_cont = Parrot_pcc_get_continuation(interp, cur_ctx);
        addr = VTABLE_invoke(interp, chosen, expr NEXT());
        goto ADDRESS(addr);
    }
    else {
        Parrot_ex_throw_from_c_args(interp, NULL, EXCEPTION_INVALID_OPERATION,
                "Internal error: multiple dispatcher returned a null candidate");
    }
}


/*

=item encodelocaltime(out INT, in PMC)

The inverse of C<decodelocaltime>.

=cut

*/
inline op encodelocaltime(out INT, in PMC) :base_core {
    struct tm tm;

    tm.tm_sec  = VTABLE_get_integer_keyed_int(interp, $2, 0);
    tm.tm_min  = VTABLE_get_integer_keyed_int(interp, $2, 1);
    tm.tm_hour = VTABLE_get_integer_keyed_int(interp, $2, 2);
    tm.tm_mday = VTABLE_get_integer_keyed_int(interp, $2, 3);
    tm.tm_mon  = VTABLE_get_integer_keyed_int(interp, $2, 4) - 1;
    tm.tm_year = VTABLE_get_integer_keyed_int(interp, $2, 5) - 1900;
    /* We needn't bother setting tm_wday or tm_yday, since mktime
    is required to ignore them. */
    tm.tm_isdst = VTABLE_get_integer_keyed_int(interp, $2, 8);

    $1 = mktime(&tm);
}

/*
 * Local variables:
 *   c-file-style: "parrot"
 * End:
 * vim: expandtab shiftwidth=4:
 */
