/*
 * Copyright (C) 2008-2011, The Perl Foundation.
 */

BEGIN_OPS_PREAMBLE

#include "parrot/parrot.h"
#include "parrot/extend.h"
#include "parrot/dynext.h"
#include "pmc_object.h"
#include "pmc_class.h"
#include "pmc_callcontext.h"
#include "pmc_sub.h"
#include "../binder/bind.h"
#include "../binder/sixmodelobject.h"

#if PARROT_HAS_ICU
#  include <unicode/uchar.h>
#endif

/* We cache a couple of type IDs for an op that we hit on every method call. */
static INTVAL p6s_id = 0;
static INTVAL or_id  = 0;
static INTVAL smo_id = 0;

static STRING *DISPATCH_JUNCTION_str;

END_OPS_PREAMBLE

/*

=item rakudo_dynop_setup()

Does various setup tasks on behalf of all of the other dynops.

=cut

*/
inline op rakudo_dynop_setup() :base_core {
    /* Look up some type IDs. */
    p6s_id = pmc_type(interp, Parrot_str_new(interp, "Perl6Scalar", 0));
    or_id  = pmc_type(interp, Parrot_str_new(interp, "ObjectRef", 0));
    smo_id = pmc_type(interp, Parrot_str_new(interp, "SixModelObject", 0));

    DISPATCH_JUNCTION_str = Parrot_str_new_constant(interp,
                                "!DISPATCH_JUNCTION_SINGLE");

    goto NEXT();
}

/*

=item find_lex_skip_current(out PMC, in STR)

Finds the lexical named $2 and returns it. However, unlike find_lex this op
skips the current sub and starts looking immediately at its outers.

=cut

*/
inline op find_lex_skip_current(out PMC, in STR) :base_core {
    PMC *ctx = CURRENT_CONTEXT(interp);
    $1 = PMCNULL;

    while (Parrot_pcc_get_outer_ctx(interp, ctx)) {
        PMC   * const outer   = Parrot_pcc_get_outer_ctx(interp, ctx);
        PMC   * const lex_pad = Parrot_pcc_get_lex_pad(interp, outer);

        if (!PMC_IS_NULL(lex_pad) && VTABLE_exists_keyed_str(interp, lex_pad, $2)) {
            $1 = VTABLE_get_pmc_keyed_str(interp, lex_pad, $2);
            break;
        }

        ctx = outer;
    }

    goto NEXT();
}


/*

=item inline op x_is_uprop(out INT, in STR, in STR, in INT)

Sets a true value in $1 if character $4 in string $3 has the unicode property
named $2.

=cut

*/
inline op x_is_uprop(out INT, in STR, in STR, in INT) :base_core {
#if PARROT_HAS_ICU
    char     *cstr;
    INTVAL    ord;
    int32_t   strwhich, ordwhich;
    UProperty strprop;
    opcode_t  *handler;

    if ($4 > 0 && (UINTVAL)$4 == ($3->strlen)) {
        $1 = 0;
        goto NEXT();
    }

    ord = Parrot_str_indexed(interp, $3, $4);
    cstr = Parrot_str_to_cstring(interp, $2);

    /* try block tests */
    if (strncmp(cstr, "In", 2) == 0) {
        strwhich = u_getPropertyValueEnum(UCHAR_BLOCK, cstr+2);
        ordwhich = u_getIntPropertyValue(ord, UCHAR_BLOCK);
        if (strwhich != UCHAR_INVALID_CODE) {
            $1 = (strwhich == ordwhich);
            Parrot_str_free_cstring(cstr);
            goto NEXT();
        }
    }

    /* try bidi tests */
    if (strncmp(cstr, "Bidi", 4) == 0) {
        strwhich = u_getPropertyValueEnum(UCHAR_BIDI_CLASS, cstr+4);
        ordwhich = u_getIntPropertyValue(ord, UCHAR_BIDI_CLASS);
        if (strwhich != UCHAR_INVALID_CODE) {
            $1 = (strwhich == ordwhich);
            Parrot_str_free_cstring(cstr);
            goto NEXT();
        }
    }

    /* try property value aliases */
    strwhich = u_getPropertyValueEnum(UCHAR_GENERAL_CATEGORY_MASK, cstr);
    if (strwhich != UCHAR_INVALID_CODE) {
        ordwhich = u_getIntPropertyValue(ord, UCHAR_GENERAL_CATEGORY_MASK);
        $1 = ((strwhich & ordwhich) != 0);
        Parrot_str_free_cstring(cstr);
        goto NEXT();
    }

    /* try property */
    strprop = u_getPropertyEnum(cstr);
    if (strprop != UCHAR_INVALID_CODE) {
        $1 = (u_hasBinaryProperty(ord, strprop) != 0);
        Parrot_str_free_cstring(cstr);
        goto NEXT();
    }

    /* try script aliases */
    strwhich = u_getPropertyValueEnum(UCHAR_SCRIPT, cstr);
    if (strwhich != UCHAR_INVALID_CODE) {
        ordwhich = u_getIntPropertyValue(ord, UCHAR_SCRIPT);
        $1 = (strwhich == ordwhich);
        Parrot_str_free_cstring(cstr);
        goto NEXT();
    }

    /* unrecognized property name */
    Parrot_str_free_cstring(cstr);
    handler =  Parrot_ex_throw_from_op_args(interp, NULL,
            EXCEPTION_ICU_ERROR,
            "Unicode property '%Ss' not found", $2);
    goto ADDRESS(handler);
#else
    opcode_t * const handler = Parrot_ex_throw_from_op_args(interp, NULL,
            EXCEPTION_ICU_ERROR,
            "ICU not loaded", $2);
    goto ADDRESS(handler);
#endif
}


/*

=item get_next_candidate_info(out PMC, out PMC, out PMC)

Looks through the outers of our caller, until we find a Routine, for a lexical
named __CANDIDATE_LIST__. Hands this lexical back in $1, the PMC for the Routine
it was found in as $2 and the lexpad of that routine as $3. This is a fairly
special-purpose op that does just what callwith, callsame, nextwith and
nextsame need.

=cut

*/
inline op get_next_candidate_info(out PMC, out PMC, out PMC) :base_core {
    PMC     *ctx         = Parrot_pcc_get_caller_ctx(interp, CURRENT_CONTEXT(interp));
    STRING  * const name = Parrot_str_new(interp, "__CANDIDATE_LIST__", 0);

    while (!PMC_IS_NULL(ctx)) {
        /* See if we've found a candidate list. */
        PMC * const lexpad = Parrot_pcc_get_lex_pad(interp, ctx);
        PMC * const clist  = VTABLE_get_pmc_keyed_str(interp, lexpad, name);
        if (!PMC_IS_NULL(clist)) {
            /* Found. Set results and we're done. */
            $1 = clist;
            $2 = Parrot_pcc_get_sub(interp, ctx);
            $3 = lexpad;
            break;
        }
        else {
            /* Not found; keep looking. */
            ctx = Parrot_pcc_get_outer_ctx(interp, ctx);
        }
    }
    if (!ctx)
        $1 = $2 = $3 = PMCNULL;

    goto NEXT();
}


/*

=item deobjectref(out PMC, in PMC)

If $2 is an ObjectRef, then follow the chain of ObjectRef
references until we get to a value of some sort (which could be
a Perl6Scalar).

=cut

*/
inline op deobjectref(out PMC, in PMC) :base_core {
    PMC * ref;
    ref = $2;
    while (ref->vtable->base_type == or_id)
        ref = VTABLE_get_pmc(interp, ref);
    $1 = ref;
    goto NEXT();
}


/*

=item descalarref(out PMC, in PMC)

If $2 is an ObjectRef or Perl6Scalar, then follow the chain of
ObjectRef/Perl6Scalar references until we get to the real
underlying value.

=cut

*/
inline op descalarref(out PMC, in PMC) :base_core {
    PMC * ref;
    ref = $2;
    while (ref->vtable->base_type == or_id || ref->vtable->base_type == p6s_id)
        ref = VTABLE_get_pmc(interp, ref);
    $1 = ref;
    goto NEXT();
}

 
/*

=item deref_unless_object(out PMC, in PMC)

If the value underlying $2 is anything but a SixModelObject.
return that value; otherwise return $2.

=cut

*/
inline op deref_unless_object(out PMC, in PMC) :base_core {
    PMC * val;
    val = $2;
    while (val->vtable->base_type == or_id || val->vtable->base_type == p6s_id)
        val = VTABLE_get_pmc(interp, val);
    $1 = (val->vtable->base_type == smo_id) ? $2 : val;
    goto NEXT();
}


/*

=item perl6_get_how(obj)

Gets the HOW for a 6model Object.

=cut

*/
inline op perl6_get_how(out PMC, in PMC) :base_core {
    PMC *get = $2;
    while (get->vtable->base_type == or_id || get->vtable->base_type == p6s_id)
        get = VTABLE_get_pmc(interp, get);
    if (get->vtable->base_type == smo_id)
        $1 = STABLE(get)->HOW;
    else
        Parrot_ex_throw_from_c_args(interp, NULL, EXCEPTION_INVALID_OPERATION,
            "Can only use perl6_get_how on a SixModelObject");
}


/*

=item perl6_get_what(obj)

Gets the WHAT for a 6model Object.

=cut

*/
inline op perl6_get_what(out PMC, in PMC) :base_core {
    PMC *get = $2;
    while (get->vtable->base_type == or_id || get->vtable->base_type == p6s_id)
        get = VTABLE_get_pmc(interp, get);
    if (get->vtable->base_type == smo_id)
        $1 = STABLE(get)->WHAT;
    else
        Parrot_ex_throw_from_c_args(interp, NULL, EXCEPTION_INVALID_OPERATION,
            "Can only use perl6_get_what on a SixModelObject");
}


/*

=item perl6_get_who(obj)

Gets the WHO for a 6model Object.

=cut

*/
inline op perl6_get_who(out PMC, in PMC) :base_core {
    PMC *get = $2;
    while (get->vtable->base_type == or_id || get->vtable->base_type == p6s_id)
        get = VTABLE_get_pmc(interp, get);
    if (get->vtable->base_type == smo_id)
        $1 = STABLE(get)->WHO;
    else
        Parrot_ex_throw_from_c_args(interp, NULL, EXCEPTION_INVALID_OPERATION,
            "Can only use get_who on a SixModelObject");
}


/*

=item bind_signature(in PMC)

This is emitted into a sub to cause it's Perl 6 signature to be bound. $1 is
the signature to bind against. The current call context is used to find the
arguments.

=cut

*/
inline op bind_signature(in PMC) :base_core {
    PMC * const ctx = CURRENT_CONTEXT(interp);

    /* If we aren't already bound, enter the appropriate binder. */
    if (!PObj_flag_TEST(P6S_ALREADY_BOUND, ctx)) {
        /* Need to make sure some stuff doesn't get destroyed. */
        PMC      * const saved_ccont = interp->current_cont;
        PMC      * const saved_sig   = Parrot_pcc_get_signature(interp, ctx);
        opcode_t * const current_pc  = Parrot_pcc_get_pc(interp, ctx);
        
        /* Obtain lexpad and other settings. */
        PMC * const lexpad        = Parrot_pcc_get_lex_pad(interp, ctx);
        const INTVAL noms_checked = PObj_flag_TEST(P6S_ALREADY_CHECKED, ctx);
        STRING * error            = STRINGNULL;
        INTVAL bind_error;

        /* Call signature binder. */
        bind_error = Rakudo_binding_bind(interp, lexpad, $1, ctx, noms_checked, &error);

        /* Bind ok? */
        if (!bind_error) {
            /* Re-instate anything we may have damaged. */
            CURRENT_CONTEXT(interp) = ctx;
            interp->current_cont    = saved_ccont;
            Parrot_pcc_set_signature(interp, ctx, saved_sig);
            Parrot_pcc_set_pc(interp, ctx, current_pc);
            goto NEXT();
        }
        else {
            /* Maybe we need to auto-thread... */
            if (bind_error == BIND_RESULT_JUNCTION) {
                /* Find dispatcher and call it. */
                PMC * const returns    = Parrot_pmc_new(interp, enum_class_CallContext);
                PMC * const dispatcher = Parrot_ns_find_namespace_global(interp, Parrot_hll_get_ctx_HLL_namespace(interp), DISPATCH_JUNCTION_str);
                PMC * const sub        = Parrot_pcc_get_sub(interp, ctx);
                opcode_t *next;
                PMC *junc_result;
                
                Parrot_ext_call(interp, dispatcher, "PP->P", sub, ctx, &junc_result);

                /* Build call signautre of returns and set it. */
                VTABLE_push_pmc(interp, returns, junc_result);
                Parrot_pcc_set_signature(interp, CURRENT_CONTEXT(interp), returns);

                /* Invoke the current return continuation, to return said value. */
                next = VTABLE_invoke(interp, Parrot_pcc_get_continuation(interp,
                        CURRENT_CONTEXT(interp)), expr NEXT());
                goto ADDRESS(next);
            }
            else {
                /* Nope, just normal fail... */
                opcode_t * const handler = Parrot_ex_throw_from_op_args(interp, NULL,
                        EXCEPTION_INVALID_OPERATION, "%Ss", error);
                goto ADDRESS(handler);
            }
        }
    }
    else {
        goto NEXT();
    }
}


/*

=item set_binder_top_type(in PMC)

Sets the top type from the binder's perspective.

=cut

*/
inline op set_binder_top_type(in PMC) :base_core {
    Rakudo_binder_set_top_type($1);
}


/*

=item set_binder_junction_type(in PMC)

Sets the junction type from the binder's perspective.

=cut

*/
inline op set_binder_junction_type(in PMC) :base_core {
    Rakudo_binder_set_junction_type($1);
}


/*

=item x_setprophash(in PMC, in PMC)

Sets the properties hash of $1 to be $2.

=cut

*/
inline op x_setprophash(in PMC, in PMC) :base_core {
    PMC_metadata($1) = $2;
    goto NEXT();
}


/*

=item find_method_null_ok(out PMC, in PMC, in STR)

Like Parrot's find_method, but returns PMCNULL in $1 if $2 doesn't have a
method named $3 instead of throwing an exception.

=cut

*/
inline op find_method_null_ok(out PMC, in PMC, in STR) :base_core {
    $1 = VTABLE_find_method(interp, $2, $3);
    goto NEXT();
}


/*

=item fixup_outer_ctx(inout PMC)

=cut

*/
inline op fixup_outer_ctx(inout PMC) :base_core {
    PMC * const cur_ctx = CURRENT_CONTEXT(interp);
    if ($1->vtable->base_type == enum_class_CallContext) {
        Parrot_pcc_set_outer_ctx(interp, $1, cur_ctx);
        goto NEXT();
    }
    else {
        opcode_t * const handler =  Parrot_ex_throw_from_op_args(interp, NULL,
                EXCEPTION_INVALID_OPERATION, "fixup_outer_ctx only valid on a context");
        goto ADDRESS(handler);
    }
}


/*

=item perl6_enter_multi_dispatch()

Entry point to multi-dispatch over the dispatchee list in the specified
candidate.

=cut

*/
inline op multi_dispatch_over_lexical_candidates(out PMC, in PMC) :base_core {
    PMC *cur_ctx = CURRENT_CONTEXT(interp);
    PMC *chosen  = Rakudo_md_dispatch(interp, $2, cur_ctx, NULL);
    if (!PMC_IS_NULL(chosen)) {
        /* Invoke the chosen candidate using a copy of the original args. */
        PMC *arg_copy = VTABLE_clone(interp, cur_ctx);
        PMC *result;
        PMC *prev_ctx = Parrot_pcc_get_signature(interp, CURRENT_CONTEXT(interp));
        Parrot_pcc_invoke_from_sig_object(interp, chosen, arg_copy);
        result = Parrot_pcc_get_signature(interp, CURRENT_CONTEXT(interp));
        Parrot_pcc_set_signature(interp, CURRENT_CONTEXT(interp), prev_ctx);
        $1 = VTABLE_get_pmc_keyed_int(interp, result, 0);
    }
    else {
        Parrot_ex_throw_from_c_args(interp, NULL, EXCEPTION_INVALID_OPERATION,
                "Internal error: multiple dispatcher returned a null candidate");
    }
}


/*

=item encodelocaltime(out INT, in PMC)

The inverse of C<decodelocaltime>.

=cut

*/
inline op encodelocaltime(out INT, in PMC) :base_core {
    struct tm tm;

    tm.tm_sec  = VTABLE_get_integer_keyed_int(interp, $2, 0);
    tm.tm_min  = VTABLE_get_integer_keyed_int(interp, $2, 1);
    tm.tm_hour = VTABLE_get_integer_keyed_int(interp, $2, 2);
    tm.tm_mday = VTABLE_get_integer_keyed_int(interp, $2, 3);
    tm.tm_mon  = VTABLE_get_integer_keyed_int(interp, $2, 4) - 1;
    tm.tm_year = VTABLE_get_integer_keyed_int(interp, $2, 5) - 1900;
    /* We needn't bother setting tm_wday or tm_yday, since mktime
    is required to ignore them. */
    tm.tm_isdst = VTABLE_get_integer_keyed_int(interp, $2, 8);

    $1 = mktime(&tm);
    goto NEXT();
}

/*
 * Local variables:
 *   c-file-style: "parrot"
 * End:
 * vim: expandtab shiftwidth=4:
 */
